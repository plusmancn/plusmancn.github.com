<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[npm-assistor, npm 包初始化和 git tag 辅助工具]]></title>
      <url>http://plusman.cn/2016/07/20/b9-npm-assistor/</url>
      <content type="html"><![CDATA[<h1 id="npm-assistor"><a href="#npm-assistor" class="headerlink" title="npm-assistor"></a>npm-assistor</h1><p><a href="https://www.npmjs.org/package/npm-assistor" target="_blank" rel="external"><img src="http://img.shields.io/npm/v/npm-assistor.svg" alt="npm-assistor"></a></p>
<blockquote>
<p>npm 包初始化和 git tag 辅助工具。源于搜车前端内部规范化改造，具体指内部功能模块 SDK 化和 GitFlow 流程规范化。Github: <a href="https://github.com/plusmancn/npm-assistor" target="_blank" rel="external">https://github.com/plusmancn/npm-assistor</a> 欢迎 star 和 pr</p>
</blockquote>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>全局安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g npm-assistor</div></pre></td></tr></table></figure></p>
<p>在项目根目录（package.json 所在文件夹）执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm-assistor</div></pre></td></tr></table></figure></p>
<p>弹出如下选择界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">? 选择要执行的命令 (Use arrow keys)</div><div class="line">  ❯ init (用于 npm 包初始化，请在 npm init 后执行) </div><div class="line">    tag (用于发布前 master 分支的 tag 标记)</div></pre></td></tr></table></figure></p>
<p><strong>选择 init 后的交互（Gif)</strong><br><img src="http://image-2.plusman.cn/image/npm-assistor-init.gif" alt="npm-assistor-init"><br><strong>选择 tag 后的交互（Gif)</strong><br><img src="http://image-2.plusman.cn/image/npm-assistor-tag.gif" alt="npm-assistor-tag"></p>
<a id="more"></a>
<h2 id="Config（Important-）"><a href="#Config（Important-）" class="headerlink" title="Config（Important!!）"></a>Config（Important!!）</h2><p><strong>config 读取规则</strong><br>优先读取用户目录下的 <code>~/.npm_assistor.yml</code> 文件，如果不存在，则使用项目默认配置。<br>默认配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">################### npm-assistor Configuration Example #########################</span></div><div class="line"></div><div class="line"><span class="comment">################## 公共模版库配置 #########################</span></div><div class="line"><span class="attr">templates:</span></div><div class="line">    <span class="comment"># github 远端配置库，会调用 api.github.com 相关 Api 进行内容获取</span></div><div class="line">    <span class="comment"># 支持多仓库</span></div><div class="line"><span class="attr">    github:</span></div><div class="line">        <span class="comment"># 可以 fork 示例模板，添加自己的配置</span></div><div class="line"><span class="attr">        - https:</span>//github.com/plusmancn/npm-assistor-template.git</div><div class="line">        <span class="comment"># - https://github.com/yourname/yourself-tempalte.git</span></div><div class="line">    <span class="comment"># Todo 最好支持下 gitlab，实现内网服务</span></div><div class="line">    <span class="comment"># gitlab:</span></div><div class="line">        <span class="comment"># - </span></div><div class="line"><span class="comment">################## gitignore 服务器地址 #########################</span></div><div class="line"><span class="comment">#  项目地址: https://github.com/joeblau/gitignore.io</span></div><div class="line"><span class="comment">#  土豪大大们，可以选择在国内部署一份，屌丝只用得起国外便宜货</span></div><div class="line"><span class="attr">gitignore_server:</span> http://gitignore.plusman.cn:<span class="number">8000</span></div></pre></td></tr></table></figure></p>
<h2 id="Init-说明"><a href="#Init-说明" class="headerlink" title="Init 说明"></a>Init 说明</h2><p><strong>eslintrc</strong><br>具体 IDE 集成参考：<a href="http://eslint.org/" target="_blank" rel="external">eslint.org</a></p>
<p><strong>LICENSE（未做集成）</strong><br><a href="https://opensource.org/licenses/alphabetical" target="_blank" rel="external">licenses list by name</a><br>并未做成命令行，具体可以参考，源码 <code>licenses-files</code> 文件夹，内含思维导图 xmind 格式<br><img src="http://image-2.plusman.cn/image/popular-license.png" alt="popular-license"></p>
<h2 id="Tag-说明"><a href="#Tag-说明" class="headerlink" title="Tag 说明"></a>Tag 说明</h2><p><strong>Tag说明</strong><br>发布号部分遵循 <a href="http://f2e.souche.com/blog/fan-yi-ru-he-zheng-que-de-ming-ming-ruan-jian-ban-ben-hao/" target="_blank" rel="external">semver</a> 规范设计，简版说明如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">格式如 $&#123;major&#125;.$&#123;feature&#125;.$&#123;patch&#125;，遵循 semver 规范的版本号</div><div class="line">    选择需要递增的版本号</div><div class="line">        major: 主版本号，用于断代更新或大版本发布</div><div class="line">        feature: 特性版本号，用于向下兼容的特性新增</div><div class="line">        patch: 修订版本号，用于 bug 修复</div><div class="line">递增位的右侧位需要清零，如 <span class="number">1.1</span><span class="number">.2</span> =&gt; <span class="number">1.2</span><span class="number">.0</span></div></pre></td></tr></table></figure></p>
<p>发布日期部分遵循 <code>{year}w{weeks}{a-z: 本周第几次发布}</code>，此部分可选，如果服务端项目发布必带；sdk 发布一般不带  </p>
<p><strong>周数定义</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</div><div class="line"><span class="comment">// 更新 week 设置</span></div><div class="line">moment.locale(<span class="string">'zh-cn'</span>, &#123;</div><div class="line">    <span class="comment">// 每年第一周的定义：</span></div><div class="line">    <span class="comment">// 国内：包含1月4号的那周为每年第一周</span></div><div class="line">    <span class="comment">// 美国：包含1月1号的那周为每年第一周（苹果日历也是如此）</span></div><div class="line">    <span class="comment">// 更新了下 moment，现在规则是 包含1月1号的那周为每年第一周，新的一周起始于周一</span></div><div class="line">    <span class="comment">//（比较好理解，苹果日历也可设置，设置-&gt;高级-&gt;显示周数）</span></div><div class="line">    week : &#123;</div><div class="line">        dow : <span class="number">1</span>, <span class="comment">// Monday is the first day of the week.</span></div><div class="line">        doy : <span class="number">7</span>  <span class="comment">// The week that contains Jan 1th is the first week of the year.</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>GitFlow 流程</strong><br>附上团队内部修改过的GitFlow 流程。<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">a-successful-git-branching-model/</a> 原博客结尾有 keynote 源码哈，可以在这基础上改出适合自己团队的 GitFlow<br><img src="http://image-2.plusman.cn/image/GitFlowV2.jpg" alt="GitFlowV2 Of souche"></p>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>Have Fun!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[日志规范化与分析监控]]></title>
      <url>http://plusman.cn/2016/07/10/b8-log-elk/</url>
      <content type="html"><![CDATA[<p><img src="http://image-2.plusman.cn/image/elk-souche-alert-v1.0.png" alt="系统概览"></p>
<h2 id="原由"><a href="#原由" class="headerlink" title="原由"></a>原由</h2><p>今天7月10号，到8月10号，正好来搜车前端一年。<br>刚来这时，还是个 Noder 新手，当然现在也是。那时面对百万行数量级的代码，一旦出个问题又没有错误栈，简直就是梦魇~。当面对线上 bug 时，便是这种窘境，然后本地测试下来，却又是好的，抓狂。<br>情急之下，先拿 <a href="https://getsentry.com/welcome/" target="_blank" rel="external">sentry</a> 顶了一段时间，项目主要应用如下：  </p>
<ul>
<li>系统未捕获错误记录</li>
<li>邮件告警提醒</li>
<li>本身也是个优秀的协作平台</li>
</ul>
<p>就这么熬了大半年，慢慢的也凸显出一些问题，比如：  </p>
<ul>
<li>仅仅是对错误栈的记录，缺少对上下文环境的记录， 对 bug 调试帮助有限。</li>
<li>搜索功能相对薄弱，历史可回溯性差。</li>
<li>团队开始有日志规范化、集群日志监控的需求，这显然不是 sentry 能做的。  </li>
</ul>
<p>于是有了 ELK + Souche-Alert 的演进。</p>
<a id="more"></a>
<h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p>俗称日志分析3剑客，是 Elasticsearch + logstash + kibana 的简称，网上搜到很多关于它们的资料，这里就简要说下几个关键配置，可配合首页图理解作用。</p>
<h3 id="filebeta-日志收割机"><a href="#filebeta-日志收割机" class="headerlink" title="filebeta 日志收割机"></a>filebeta 日志收割机</h3><p><a href="https://www.elastic.co/downloads/beats/filebeat" target="_blank" rel="external">filebeat 下载地址</a> ，无需安装可直接执行 <code>bin</code> 命令<br><strong>启动 filebeta</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./filebeat -e -c filebeat.yml -d &apos;*&apos;</div></pre></td></tr></table></figure></p>
<p><strong>配置文件</strong>  </p>
<ul>
<li>设置需要监听的日志路径</li>
<li>设置 logstash 地址</li>
<li>记得确认下 Elasticsearch 的默认配置有没有移除<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">filebeat:</div><div class="line">  # List of prospectors to fetch data.</div><div class="line">  prospectors:</div><div class="line">    # Each - is a prospector. Below are the prospector specific configurations</div><div class="line">    -</div><div class="line">      # Paths that should be crawled and fetched. Glob based paths.</div><div class="line">      # To fetch all &quot;.log&quot; files from a specific level of subdirectories</div><div class="line">      # /var/log/*/*.log can be used.</div><div class="line">      # For each file found under this path, a harvester is started.</div><div class="line">      # Make sure not file is defined twice as this can lead to unexpected behaviour.</div><div class="line">      paths:</div><div class="line">        - /tmp/bunyan-cheniu-error.log</div><div class="line">        # - /var/log/*.log</div><div class="line">        #- c:\programdata\elasticsearch\logs\*</div><div class="line">### Logstash as output</div><div class="line">logstash:</div><div class="line">  # The Logstash hosts</div><div class="line">  hosts: [&quot;127.0.0.1:5043&quot;]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="logstash-日志中转站"><a href="#logstash-日志中转站" class="headerlink" title="logstash 日志中转站"></a>logstash 日志中转站</h3><p><a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">logstash 下载地址</a><br><strong>启动 logstash</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/logstash -f config/cheniu.conf</div></pre></td></tr></table></figure></p>
<p><strong>配置 logstash</strong><br>日志格式选择的是 JSON 格式，默认模板会对所有 String 类型的字段做索引和分词操作，这里使用了自定义的模板，指定某些字段，不需要进行索引，以提高 ElasticSearch 的搜索性能 &amp; 节省存储空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># The # character at the beginning of a line indicates a comment. Use</div><div class="line"># comments to describe your configuration.</div><div class="line"># filebeats 中的 hosts 配置需要和这里对应，这里选择了对分析最友好的 json log 格式</div><div class="line">input &#123;</div><div class="line">    beats &#123;</div><div class="line">        type =&gt; &quot;cheniu_api_server&quot;</div><div class="line">        port =&gt; &quot;5043&quot;</div><div class="line">        codec =&gt; &quot;json&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"># The filter part of this file is commented out to indicate that it is</div><div class="line"># optional.</div><div class="line">filter &#123;</div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;</div><div class="line">        index =&gt; &apos;cheniu-api-test-%&#123;+YYYY.MM.dd&#125;&apos;</div><div class="line">        template =&gt; &apos;/home/yourname/logdir/logstash-2.3.2/config/cheniu-api-template.json&apos;</div><div class="line">        template_name =&gt; &apos;cheniu-api&apos;</div><div class="line">        template_overwrite =&gt; true</div><div class="line">    &#125;</div><div class="line">    stdout &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以在 logstash 的项目内搜索 <code>elasticsearch-template.json</code> 看到默认模板。下面是自定义优化过的模板，主要更改在 <code>properties</code> 部分。暂时还没有中文分词的需求，如果有的话，需要对包含中文的字段指定分词引擎。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"template"</span> : <span class="string">"cheniu-api-*"</span>,</div><div class="line">  <span class="attr">"settings"</span> : &#123;</div><div class="line">    <span class="attr">"index.refresh_interval"</span> : <span class="string">"10s"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"mappings"</span> : &#123;</div><div class="line">    <span class="attr">"_default_"</span> : &#123;</div><div class="line">      <span class="attr">"_all"</span> : &#123;<span class="attr">"enabled"</span> : <span class="literal">true</span>, <span class="attr">"omit_norms"</span> : <span class="literal">true</span>&#125;,</div><div class="line">      <span class="attr">"dynamic_templates"</span> : [ &#123;</div><div class="line">        <span class="attr">"message_field"</span> : &#123;</div><div class="line">          <span class="attr">"match"</span> : <span class="string">"message"</span>,</div><div class="line">          <span class="attr">"match_mapping_type"</span> : <span class="string">"string"</span>,</div><div class="line">          <span class="attr">"mapping"</span> : &#123;</div><div class="line">            <span class="attr">"type"</span> : <span class="string">"string"</span>, <span class="attr">"index"</span> : <span class="string">"analyzed"</span>, <span class="attr">"omit_norms"</span> : <span class="literal">true</span>,</div><div class="line">            <span class="attr">"fielddata"</span> : &#123; <span class="attr">"format"</span> : <span class="string">"disabled"</span> &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;, &#123;</div><div class="line">        <span class="attr">"string_fields"</span> : &#123;</div><div class="line">          <span class="attr">"match"</span> : <span class="string">"*"</span>,</div><div class="line">          <span class="attr">"match_mapping_type"</span> : <span class="string">"string"</span>,</div><div class="line">          <span class="attr">"mapping"</span> : &#123;</div><div class="line">            <span class="attr">"type"</span> : <span class="string">"string"</span>, <span class="attr">"index"</span> : <span class="string">"analyzed"</span>, <span class="attr">"omit_norms"</span> : <span class="literal">true</span>,</div><div class="line">            <span class="attr">"fielddata"</span> : &#123; <span class="attr">"format"</span> : <span class="string">"disabled"</span> &#125;,</div><div class="line">            <span class="attr">"fields"</span> : &#123;</div><div class="line">              <span class="attr">"raw"</span> : &#123;<span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"index"</span> : <span class="string">"not_analyzed"</span>, <span class="attr">"ignore_above"</span> : <span class="number">256</span>&#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; ],</div><div class="line">      <span class="attr">"properties"</span> : &#123;</div><div class="line">        <span class="attr">"name"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span>&#125;,</div><div class="line">        <span class="attr">"req_id"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span>&#125;,</div><div class="line">        <span class="attr">"@timestamp"</span>: &#123; <span class="attr">"type"</span>: <span class="string">"date"</span> &#125;,</div><div class="line">        <span class="attr">"@version"</span>: &#123; <span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span> &#125;,</div><div class="line">        <span class="attr">"geoip"</span>  : &#123;</div><div class="line">          <span class="attr">"dynamic"</span>: <span class="literal">true</span>,</div><div class="line">          <span class="attr">"properties"</span> : &#123;</div><div class="line">            <span class="attr">"ip"</span>: &#123; <span class="attr">"type"</span>: <span class="string">"ip"</span> &#125;,</div><div class="line">            <span class="attr">"location"</span> : &#123; <span class="attr">"type"</span> : <span class="string">"geo_point"</span> &#125;,</div><div class="line">            <span class="attr">"latitude"</span> : &#123; <span class="attr">"type"</span> : <span class="string">"float"</span> &#125;,</div><div class="line">            <span class="attr">"longitude"</span> : &#123; <span class="attr">"type"</span> : <span class="string">"float"</span> &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">ElasticSearch 下载地址</a> ，同样免安装，目前还没有集群需求，所以拿来就能用。</p>
<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p><a href="https://www.elastic.co/products/kibana" target="_blank" rel="external">kibana</a> 强大的日志可视化面板，配置下 ElasticSearch 地址后，即可使用。</p>
<h3 id="Souche-Alert"><a href="#Souche-Alert" class="headerlink" title="Souche-Alert"></a>Souche-Alert</h3><p>Elastic 公司有 <a href="https://www.elastic.co/products/watcher" target="_blank" rel="external">watcher</a> 的商用产品，嫌配置略繁、灵活性不够 + 收费，自己用 Node 撸了一个告警中心，大概原理是定时调用 ElasticSearch 的搜索 Api，查询错误日志，根据触发逻辑，判断是否需要发送告警邮件。<br>好处如下：  </p>
<ul>
<li>javascript 的技术栈 谁都能上去写几个监控。（我在前端团队）</li>
<li>原理够简单粗暴，所以足够稳定，调试也很简单。</li>
<li>Free！</li>
</ul>
<h2 id="Log-的生成约定"><a href="#Log-的生成约定" class="headerlink" title="Log 的生成约定"></a>Log 的生成约定</h2><p>针对 <a href="https://github.com/trentm/node-bunyan" target="_blank" rel="external">bunyan</a> 团队内部又做了一层封装，做了一个叫做 bylog 的私有 npm 包，用于生成 json 格式的日志。<br>做了如下改进：  </p>
<ul>
<li>node xx.js | bunyan 命令更改为一个可配置参数，用于日志格式化输出。</li>
<li>增加 meta 字段支持，用于记录额外的上下文信息。</li>
<li>增加静默通道，日志可选择只输出到文件，用于请求信息的记录。</li>
<li>为防止日志索引内出现 name.xxx.cc 的 name 字段，对 json 日志第二层后的数据用 util.inspect 做了最多5层的转义，考虑到性能，不能再多了。</li>
</ul>
<h3 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bylog = <span class="built_in">require</span>(<span class="string">'../'</span>);</div><div class="line"><span class="comment">// 终端输出格式化，做了 node xxx.js | bunyan 的事</span></div><div class="line"><span class="keyword">const</span> logOutput = <span class="built_in">require</span>(<span class="string">'../lib/log_output.js'</span>); </div><div class="line"></div><div class="line"><span class="comment">// 支持 bunyan (https://github.com/trentm/node-bunyan) 所有参数 </span></div><div class="line"><span class="keyword">let</span> logOpt = &#123;</div><div class="line">    name: <span class="string">'cheniu-pro'</span>,</div><div class="line">    src: <span class="literal">false</span>,</div><div class="line">    streams: [</div><div class="line">        &#123;</div><div class="line">            level: <span class="string">'info'</span>,</div><div class="line">            path: <span class="string">'/tmp/bunyan-cheniu-pro.log'</span>,</div><div class="line">            mute: <span class="literal">true</span> <span class="comment">// 只输出到文件，不在终端输出，呼应输出函数 Options mute 参数</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            level: <span class="string">'trace'</span>,</div><div class="line">            stream: logOutput <span class="comment">// process.stdout</span></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> byLog = bylog.createLogger(logOpt);</div></pre></td></tr></table></figure>
<h3 id="level-约定"><a href="#level-约定" class="headerlink" title="level 约定"></a>level 约定</h3><p>The log <a href="https://github.com/trentm/node-bunyan#levels" target="_blank" rel="external">levels</a> in bunyan are as follows. The level descriptions are best practice opinions of the author.</p>
<ul>
<li>“fatal” (60): The service/app is going to stop or become unusable now. An operator should definitely look into this soon.</li>
<li>“error” (50): Fatal for a particular request, but the service/app continues servicing other requests. An operator should look at this soon(ish).</li>
<li>“warn” (40): A note on something that should probably be looked at by an operator eventually.</li>
<li>“info” (30): Detail on regular operation.</li>
<li>“debug” (20): Anything else, i.e. too verbose to be included in “info” level.</li>
<li>“trace” (10): Logging from external libraries used by your app or very detailed application logging.</li>
</ul>
<p><strong>info（含）以上级别日志将被记录到日志平台，level:&gt;=50 日志，会有邮件警告，需要立即处理。</strong></p>
<p>在项目内，通过如下函数输出不同级别日志，byLog 挂载在 global 对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">byLog.&#123;level&#125;(err[, meta[, append]]);</div><div class="line">- &#123;<span class="built_in">Error</span>|<span class="built_in">String</span>&#125;err   <span class="built_in">Error</span> 对象或者字符串.</div><div class="line">- &#123;<span class="built_in">JSON</span>|<span class="built_in">String</span>&#125;meta  [可选] 用于记录错误发生时的上下文信息</div><div class="line">- &#123;<span class="built_in">JSON</span>&#125;append [可选] 目前支持如下参数</div><div class="line">  - &#123;<span class="built_in">String</span>&#125;req_id  请求唯一 id，项目内可以从 req.x_request_id 上获取，用于将报错和某次 API 请求绑定</div><div class="line">  - &#123;<span class="built_in">Boolean</span>&#125;mute 默认 <span class="literal">false</span>，强制不在终端输出</div><div class="line"></div><div class="line"><span class="comment">// 示例 Test</span></div><div class="line">byLog.trace(<span class="string">'trace message here'</span>);</div><div class="line">byLog.debug(<span class="string">'debug message here'</span>, <span class="string">'meta message here'</span>);</div><div class="line">byLog.info(<span class="string">'info message here'</span>, &#123;infoKey: <span class="string">'infoValue'</span>&#125;);</div><div class="line">byLog.warn(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'warn message here'</span>), &#123;infoKey: <span class="string">'infoValue'</span>&#125;);</div><div class="line">byLog.error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error message here'</span>), &#123;</div><div class="line">    url: <span class="string">'http://www.souche.com'</span>,</div><div class="line">    token: &#123;</div><div class="line">        <span class="keyword">from</span>: <span class="string">'usercenter'</span>,</div><div class="line">        value: <span class="string">'jdi90knen'</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">byLog.fatal(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fatal message here'</span>), <span class="literal">null</span>, &#123;req_id: <span class="string">'xxx'</span>&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>注意：！并不是所有 Error 都需要 error（含）以上级别，根据影响程度，由开发者自行决定</strong></p>
<h2 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p><strong>收集渠道</strong>  </p>
<ul>
<li>系统未捕获错误，埋点如下，输出级别为 <code>error</code>。  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'uncaughtException'</span>, processErrorHandler);</div><div class="line">process.on(<span class="string">'unhandledRejection'</span>, processErrorHandler);</div></pre></td></tr></table></figure>
<ul>
<li>程序内 byLog 的输出</li>
<li>console.error 等于 byLog.error</li>
<li>针对 Express 可做如下埋点  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在所有路由最后，添加错误处理，必须同时含有四个参数</span></div><div class="line"><span class="comment">// http://expressjs.com/en/guide/error-handling.html</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">    res.send(&#123;</div><div class="line">        code: <span class="number">500</span>,</div><div class="line">        message: <span class="string">`System Error! Please send serial number <span class="subst">$&#123;req.x_request_id&#125;</span> to administer`</span></div><div class="line">    &#125;);</div><div class="line">    byLog.error(err, <span class="literal">null</span>, &#123;</div><div class="line">        req_id: req.x_request_id</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="请求链路信息"><a href="#请求链路信息" class="headerlink" title="请求链路信息"></a>请求链路信息</h3><p>bylog 框架内有个中间件，做了如下事情</p>
<ul>
<li>如果请求 <code>header</code> 部分未指定 <code>X-Request-Id</code>，则系统自动填充格式如 <code>w{weeks}{day of week}_uuid</code> 值。  </li>
<li>默认记录每次 API 请求的完整参数、头部信息，并在 Express 的 <code>req.x_request_id</code> 上绑定本次请求的 <code>X-Request-Id</code>。  </li>
<li>在 API 响应体 <code>header</code> 部分返回 <code>X-Request-Id</code> 字段。</li>
</ul>
<p>在 Express 的实际应用中，我们还对 res.send 函数做了一次 hack，将 json 格式的返回记录下来，并将请求对象通过 <code>req.x_request_id</code> 进行进行关联。</p>
<blockquote>
<p>res.send 函数有个暗坑，如果你传一个 json 对象进去，那么函数会先进行一轮类型判断，将 json 转换为字符串后，再次回调 res.send。</p>
</blockquote>
<p>最佳实践：<br>错误输出的时候传入 <code>req.x_request_id</code> 值，将错误和某个请求进行关联。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byLog.fatal(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fatal message here'</span>), &#123;key: <span class="string">'keyValue'</span>&#125;, &#123;req_id: <span class="string">'xxx'</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>在日志面板搜索栏输入如下语句，即可将某次请求的所有日志信息聚合查看（注意搜索时候，时间范围的选择）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req_id: &apos;w224_9666a363-af8b-4c8a-a5f4-312078763961&apos;</div></pre></td></tr></table></figure></p>
<p>测试联调阶段，测试人员抓包后，只需将 <code>X-Request-Id</code> 值给服务端人员即可。<br>发现线上问题，同理也可看到完整的链路信息。</p>
<h3 id="自定义监控逻辑"><a href="#自定义监控逻辑" class="headerlink" title="自定义监控逻辑"></a>自定义监控逻辑</h3><p><strong>针对关键指标，可以通过 ElasticSearch 的日志搜索功能，在Souche-Alert 书写自定义的监控逻辑</strong></p>
<p>例如队列健康状态监控，关键业务指标，自由发挥。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://kibana.logstash.es/content/logstash/examples/nginx-access.html" target="_blank" rel="external">ELKstack 中文指南</a>  </li>
<li><a href="https://www.elastic.co/" target="_blank" rel="external">elastic 的产品文档们</a></li>
</ul>
<h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>日志规范化与分析监控是一个漫长但是有意义的过程，规范化是分析监控的基础，一团乱麻是理不清的。这需要持续的耐心和推动，但是复出总归会有回报的，看着干净的日志输出、能比用户先发现问题，便是满满的愉悦感。  </p>
<p>一些还在内部使用的工具包，向芋头大大咨询下意见，应该很快就能作为一个方案打包开源。  </p>
<p>日志规范化与分析监控，搜车也还有很多路要走，比如  </p>
<ul>
<li>网络 I/O 的监控</li>
<li>elk 的集群部署</li>
<li>日志的清洗和静默规则</li>
<li>kibana 数据可视化的利用</li>
<li>更加多样化的告警渠道，如微信、短信</li>
<li>多技术栈的兼容，如 node，java，ruby  </li>
<li>…</li>
</ul>
<p>愿天下没有 P0 bug</p>
<p>PS: 今天我生日</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[callback 和 promise 的错误捕获]]></title>
      <url>http://plusman.cn/2016/05/09/b7-error-catch/</url>
      <content type="html"><![CDATA[<p><img src="http://image-2.plusman.cn/image/callbacks_promises.png?imageView2/2/w/920/interlace/0/q/100" alt="ctp"></p>
<blockquote>
<p>1) 千万不要去尝试 catch callback 的回调错误，错误处理应交由 callbac 函数本身。开发中碰到过框架捕获了 callback 的错误，而且直接湮没了，导致代码出了问题，却不能察觉。<br>2)  对于进程的 uncaughtException, unhandledRejection 事件，建议结合日志做一些监听处理。</p>
</blockquote>
<a id="more"></a>
<h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><p>下面是一个 catch callback 回调的错误示例，开发中要避免，运行 <code>callbask.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbAfter3s</span>(<span class="params">callback</span>) </span>&#123;  </div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// s2</span></div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            callback(<span class="literal">null</span>, <span class="string">'3s'</span>);</div><div class="line">        &#125;<span class="keyword">catch</span>(e) &#123;</div><div class="line">            <span class="built_in">console</span>.error(<span class="string">'Catch in cbAfter3s'</span>, e);</div><div class="line">            callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error from cbAfter3s'</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error from cbAfter3s ASync'</span>);</div><div class="line">    &#125;, <span class="number">3e3</span>);</div><div class="line"></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error from cbAfter3s Sync'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">'Reveive: '</span>, err, data);</div><div class="line">    <span class="keyword">if</span>(!err) &#123;</div><div class="line">        <span class="comment">// s2</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error from handle'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    cbAfter3s(handle);</div><div class="line">&#125;<span class="keyword">catch</span>(e) &#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'Catch in global'</span>, e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;  </div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'Catch in process'</span>, e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Catch in global [Error: Error from cbAfter3s Sync]</div><div class="line">Reveive:  null 3s</div><div class="line">Catch in cbAfter3s [Error: Error from handle]</div><div class="line">Reveive:  [Error: Error from cbAfter3s] undefined</div><div class="line">Catch in process [Error: Error from cbAfter3s ASync]</div></pre></td></tr></table></figure></p>
<p>总结（s）：  </p>
<ol>
<li>try catch 只能捕获同步抛出的错误</li>
<li>不要轻易在 callback 里 throw 错误，不然容易形成两次回调。</li>
<li>代码未捕获的错误，会出现在 uncaughtException 事件上，建议做些日志记录；不然，假如你用了进程守护程序（如pm2等），会自动重启应用，进而湮没日志。</li>
<li>promise 的错误捕获又是不同的，不能想当然。</li>
</ol>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>运行 <code>promise.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 内置P romise</span></div><div class="line"><span class="keyword">var</span> p = (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error from promise by reject'</span>));</div><div class="line">    <span class="comment">// 或者通过 throw 的方式抛出，效果相同 </span></div><div class="line">    <span class="comment">// throw new Error('Error from promise by throw');</span></div><div class="line"></div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="comment">// 或者在 then 通过 throw 抛出错误，也有同样效果</span></div><div class="line"><span class="comment">/**</span></div><div class="line">var p = (new Promise(function(resolve)&#123;</div><div class="line">    resolve('Data');</div><div class="line">&#125;))</div><div class="line">.then(function(res)&#123;</div><div class="line">    console.info('Receive: ', res);</div><div class="line">    throw new Error('Error from promise by throw');</div><div class="line">&#125;);</div><div class="line">*/</div><div class="line"></div><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'UE:Catch in process'</span>, e);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">process.on(<span class="string">'unhandledRejection'</span>, (reason) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">'UR:Catch in process'</span>, reason);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.on(<span class="string">'rejectionHandled'</span>, (p) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">'RH:Catch in process'</span>, p);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="string">'Catch in Promise'</span>, e);</div><div class="line">    &#125;);</div><div class="line">&#125;, <span class="number">1e3</span>);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UR:Catch in process [Error: Error from promise by reject]</div><div class="line">RH:Catch in process Promise &#123; &lt;rejected&gt; [Error: Error from promise by reject] &#125;</div><div class="line">Catch in Promise [Error: Error from promise by reject]</div></pre></td></tr></table></figure></p>
<p>总结（s）:  </p>
<ol>
<li><code>rejectionHandled</code> 事件的触发条件为，<code>promise</code> 没有被及时 catch 到错误并触发了 <code>unhandledRejection</code> 事件，在这之后的一段时间里，<code>promise</code> 错误又被处理了，此时触发 <code>rejectionHandled</code>，详情见 <a href="https://nodejs.org/docs/v4.4.4/api/process.html#process_event_rejectionhandled" target="_blank" rel="external">Node-Docs-4.4.1#process_event_rejectionhandled</a>。</li>
<li><code>uncaughtException</code> 并不能捕获 <code>Promise</code> 内抛出的错误，如果开发者是从基于 callback 的 <a href="https://github.com/caolan/async" target="_blank" rel="external">Async</a> 转向 <code>Promise</code> 的，尤其需要注意未知错误的捕获。</li>
</ol>
<p>由于历史代码历史包袱，有时我们会写一个 <code>promiseToCallback</code> 的函数，类似如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseToCallback</span>(<span class="params">func</span>)</span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">let</span> cb = args.pop();</div><div class="line">        func.apply(<span class="literal">null</span>, args)</div><div class="line">            .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">                cb(<span class="literal">null</span>, result);</div><div class="line">            &#125;)</div><div class="line">            .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">                log.error(err);</div><div class="line">                cb(err);</div><div class="line">            &#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这时候，尤其需要当心，cb 内如果抛出错误，会触发 catch 事件，导致发生两次回调。</p>
<blockquote>
<p>希望这些能让你在开发中少踩些坑。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[note][翻译] 如何正确的命名软件版本号]]></title>
      <url>http://plusman.cn/2016/02/23/n1-note-semver/</url>
      <content type="html"><![CDATA[<p><img src="http://image-2.plusman.cn/image/semver-v2.jpg" alt="SemVer"><br>[图解] <a href="https://www.npmjs.com/package/semver#caret-ranges-123-025-004" target="_blank" rel="external">Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4</a> 。<code>^</code> 符号，是不允许改变最左非零数字，1.x.x 系列见得最多，容易形成误解。正确的升级规则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* ^1.2.3 := &gt;=1.2.3 &lt;2.0.0</div><div class="line">* ^0.2.3 := &gt;=0.2.3 &lt;0.3.0</div><div class="line">* ^0.0.3 := &gt;=0.0.3 &lt;0.0.4</div></pre></td></tr></table></figure></p>
<blockquote>
<p>原文地址：<a href="http://www.plusman.cn/2016/02/23/note-semver/" target="_blank" rel="external">http://www.plusman.cn/2016/02/23/note-semver/</a><br>官方网站：<a href="http://semver.org/" target="_blank" rel="external">semver 版本管理规范</a><br>原中文译本：<a href="http://semver.org/lang/zh-CN/" target="_blank" rel="external">http://semver.org/lang/zh-CN/</a>，基于此整理<br>水平有限（真心的），翻译得撕心裂肺，求大神斧正。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="语义化版本-2-0-0"><a href="#语义化版本-2-0-0" class="headerlink" title="语义化版本 2.0.0"></a>语义化版本 2.0.0</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>
<ol>
<li>主版本号：当你做了不兼容的 API 修改，</li>
<li>次版本号：当你做了向下兼容的功能性新增，</li>
<li>修订号：当你做了向下兼容的 bug 修复。</li>
</ol>
<p>其他标签，如预发版本、构建元信息，可以拓展到“主版本号.次版本号.修订号”的后面。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在软件管理的领域里存在着被称作“依赖黑洞”的糟糕情景，随着软件系统规模的增大，所依赖套件的增多，你就越有可能在未来的某一天发现自己已经焦头烂额。</p>
<p>面对一个拥有复杂依赖的系统，每一次依赖更新都像是一场噩梦。如果依赖包的版本号指定过于严格（译注：参见注解1），可能会面临依赖版本被死锁的风险（必须对每一个依赖手动更改版本号后才能完成某次升级）。而如果依赖关系过于松散，又会极易遇到依赖版本失控（比如为了使用最新版的依赖，而不停的更改项目代码，而这些升级不一定合理）。“依赖黑洞”所导致的版本死锁和版本失控问题，阻碍着项目的平滑升级。</p>
<p>因此，我提议用一组简单的制度规范来约束版本号的设定和增长。这些规则基于（但不局限于）已经被各种闭源、开源码软件所广泛实践的规范。为了让这套规则运作，你首先需要声明一个公共 API 列表，这可以是一个文档约定，或者在代码里只暴露需要开放的功能接口。无论如何，这套 API 的定义需要清晰而且精确。一旦你定义了公共 API，就要保持 API 列表和版本号同步更新。考虑使用这样格式的版本号：X.Y.Z （主版本号.次版本号.修订号），bug 修复且不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。</p>
<p>我称这套系统为“语义化的版本控制”，在这套约定下，每一次版本号的更新都对应着相应的代码改动。</p>
<h3 id="语义化版本控制规范（SemVer）"><a href="#语义化版本控制规范（SemVer）" class="headerlink" title="语义化版本控制规范（SemVer）"></a>语义化版本控制规范（SemVer）</h3><p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 <a href="http://tools.ietf.org/html/rfc2119" target="_blank" rel="external">RFC 2119</a> 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。）</p>
<ol>
<li><p>使用语义化版本控制的软件<code>必须</code>定义公共 API。该 API 可以在代码中被定义或用严谨的文档描述。无论何种形式都应该力求全面和精确。</p>
</li>
<li><p>标准的版本号<code>必须</code>采用 X.Y.Z 的格式，其中 X、Y、Z 为非负的整数，且<code>禁止</code>在数字前方加前导零。X 是主版本号、Y 是次版本号、 Z 为修订号。每个元素<code>必须</code>以数值来递增。例如：1.9.0 -&gt; 1.10.0 -&gt; 1.11.0。</p>
</li>
<li><p>带版本号的软件发行后，<code>禁止</code>改变该版本软件的内容。任何修改都<code>必须</code>以新版本发行。</p>
</li>
<li><p>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</p>
</li>
<li><p>1.0.0 的版本号用于标识稳定 API 的发布。这一版本之后，所有的版本号更新都基于公共 API 的修改内容。</p>
</li>
<li><p>修订号 Z（x.y.Z | x &gt; 0）<code>必须</code>在只做了向下兼容的 bug 修复时才递增。bug 修复的定义是，修改程序内部行为，使其输出正确的结果。</p>
</li>
<li><p>次版本号 Y（x.Y.z | x &gt; 0）<code>必须</code>在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也<code>必须</code>递增。也<code>可以</code>在内部程序有大量功能更新或改进时递增。其中<code>可能</code>包括修订号的改变。每当次版本号递增时，修订号<code>必须</code>置零。</p>
</li>
<li><p>主版本号 X（X.y.z | X &gt; 0）<code>必须</code>在有任何不向下兼容的修改被加入公共 API 时递增。其中<code>可能</code>包括次版本号及修订号的改变。每当主版本号递增时，次版本号和修订号<code>必须</code>置零。</p>
</li>
<li><p>预发版本号<code>可以</code>被标注在修订号之后，由一个连接号（译注：-）再加上一连串以句点（译注：.）分隔的标识符号组成。标识符号<code>必须</code>由 ASCII 的英数字和连接号 [0-9A-Za-z-] 组成，且<code>禁止</code>留白。数字型的标识符号<code>禁止</code>添加前导零。预发版的优先级低于相关联的标准版本。预发版本表示这个版本并不稳定，而且可能会和标准版本不兼容。例如：<code>1.0.0-alpha，1.0.0-alpha.1，1.0.0-0.3.7，1.0.0-x.7.z.92</code>。</p>
</li>
<li><p>版本构建元信息<code>可以</code>被标注在修订版或预发版本号之后，由一个加号（译注：+）再加上一连串以句点（译注：.）分隔的标识符号组成。标识符号<code>必须</code>由 ASCII 的英数字和连接号 [0-9A-Za-z-] 组成，且<code>禁止</code>留白。当判断版本的优先层级时，版本构建元信息<code>可以</code>被忽略。 因此当两个版本只有版本构建元信息有差别时，属于相同的优先层级。例如：<code>1.0.0-alpha+001，1.0.0+20130313144700，1.0.0-beta+exp.sha.5114f85</code>。</p>
</li>
<li><p>标识符的优先层级决定不同版本号在比较时如何排序。判断优先层级时，<code>必须</code>把版本号依序拆分为主版本号、次版本号、修订号及预发版本号后进行比较（版本构建元信息不在这份比较的列表中）。由左到右依序比较每个标识符号，通过第一个差异值来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，带预发版本号的比标准版本号优先级低，例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个预发版本号，其优先层级<code>必须</code>透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：数字标识符号以数值高低比较，有字母或连接号时则逐字以 ASCII 码的大小来比较。数字的标识符号比非数字的标识符号优先层级低。若开头的标识符号都相同时，分段比较多的预发版本号优先层级比较高。范例：<code>1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0- rc.1 &lt; 1.0.0</code>（译注：参见注解2）。</p>
</li>
</ol>
<h3 id="为什么要使用语义化的版本控制？"><a href="#为什么要使用语义化的版本控制？" class="headerlink" title="为什么要使用语义化的版本控制？"></a>为什么要使用语义化的版本控制？</h3><p>这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清晰的定义，能够让你更好的与软件使用者交流。一旦这些设计意图的转达变得清晰，灵活（但又适度）的依赖规范就能达成。</p>
<p>举个简单的例子来展示语义版本是如何解决“依赖黑洞”的。假设有个名为“消防车”的函数库，它需要另一个名为“梯子”并已经有使用语义化版本控制的套件。当“消防车”创建时，“梯子“的版本号为 3.1.0。因为“消防车”只使用了版本 3.1.0 的部分功能， 你可以放心地指定所依赖“梯子“的版本号大于等于 3.1.0 但小于 4.0.0。这样，当“梯子“发布 3.1.1 和 3.2.0 版本时，你可以直接利用你的套件管理系统升级“梯子”，因为它们能与现有的“消防车”兼容。</p>
<p>作为一位负责任的开发者，理当确认每个依赖包是否按照规范升级。但是现实世界是混乱的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级依赖，而无需为了某个依赖单独更新代码，从而节省你的时间和精力。</p>
<p>如果你对此认同，希望立即开始使用语义化版本控制来管理你的项目。请在你的 README 文件中添加此页链接，让别人也知道这些规则并从中受益。</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>Q：在 0.y.z 的初始开发阶段，我该如何进行版本控制?<br>A：最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p>
<p>Q：如何判断发布 1.0.0 版本的时机？<br>A：当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也应是 1.0.0 版。如果你有很多向下兼容的问题要考虑，也应该算是 1.0.0 版了。</p>
<p>Q：这不会阻碍快速开发和迭代吗？<br>A：主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。</p>
<p>Q：对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？<br>A：这是开发者的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价必须是有意义的。要递增主版本号来发行不兼容的版本，意味着你已经为这些改变所带来的影响慎重考虑过，并且评估了所涉及的<code>成本/效益</code>比。</p>
<p>Q：为整个公共 API 写文档太费时间了！<br>A：为供他人使用的软件编写正确的文档，是你作为一名专业开发者应尽的职责。保证项目高效运转，一个很重要的方面是控制软件复杂度，如果没有人知道如何使用你的软件，或如何安全的调用你的函数，这将很难做到。长远来看，使用语义版本，并坚持定义清晰的公共 API，能够使得项目平滑推进。</p>
<p>Q：万一不小心发布了不兼容的更新，但只更改了次版本号，该如何补救？<br>A：一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题，并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。</p>
<p>Q：如果我更新了自己的依赖但没有改变公共 API 该怎么办？<br>A：由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的套件有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我认为通常需要写额外的代码，这显然会是一个次版本号级别的递增。</p>
<p>Q：如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）<br>A：自行做最佳的判断。如果你有庞大的用户群，会因为回退公共 API 功能，受到严重的影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住，语义化的版本控制就是透过版本号的改变来传递信息。若这些改变对你的使用者是重要的，那就透过版本号来向告知他们。</p>
<p>Q：我该如何处理即将弃用的功能？<br>A：弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文档让使用者知道这个改变。（2）发行一个次版本号来标记将要废弃的 API。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用 API，这样使用者才能平滑的过渡到新 API。</p>
<p>Q：语义化版本对于版本的字符串长度是否有限制呢？<br>A：没有，请自行做适当的判断。举例来说，一个长度为255个字符的版本号，已经很夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。</p>
<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>语义化版本控制的规范是由 Gravatars 创始人兼 GitHub 联合创始人之一的 <a href="http://tom.preston-werner.com/" target="_blank" rel="external">Tom Preston-Werner</a> 所起草的。</p>
<p>如果您有任何建议，请 <a href="https://github.com/mojombo/semver/issues" target="_blank" rel="external">open an issue on GitHub</a>。</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p><a href="http://creativecommons.org/licenses/by/3.0/" target="_blank" rel="external">创作共享 - CC BY 3.0</a></p>
<hr>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ol>
<li><a href="http://stackoverflow.com/questions/22343224/difference-between-tilde-and-caret-in-package-json" target="_blank" rel="external">Difference between tilde(~) and caret(^) in package.json</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E7%89%88%E6%9C%AC%E9%80%B1%E6%9C%9F" target="_blank" rel="external">软件版本周期</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[(node性能优化二) API粒度实践]]></title>
      <url>http://plusman.cn/2016/01/11/b4-mini-unit/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Written with <a href="http://www.vim.org/" target="_blank" rel="external">vim</a></p>
</blockquote>
<hr>
<p><img src="http://image-2.plusman.cn/image/wpid-Photo-Apr-4-2013-105-PM.jpg" alt="simple vs complex"></p>
<blockquote>
<p>把复杂拆分成简单，将简单组合成强大，再用强大去解决复杂。<code>--</code> Unix的设计思想之一</p>
</blockquote>
<p>最近在做公司消息中心的重构，是个大坑。老代码会把大批量的任务往内存里面塞入，经常跑着就不知道那里挂了，然后任务也丢失了。<br>重构主要做了如下几件事</p>
<ol>
<li>API功能单一化（降低API粒度）</li>
<li>将任务队列化并做持久存储，做成消费模型</li>
<li>工作进程之间的相互独立，防止互相干扰。</li>
</ol>
<hr>
<a id="more"></a>
<blockquote>
<p>关于API粒度，粗细各有好处，在这不敢妄下定论，只结合特定场景，给些实践心得。至于如何把握，是经验的积累，不停的摸索，最重要的是弄清场景下的需求。</p>
</blockquote>
<h2 id="I-O-角度上的WEB-API粒度"><a href="#I-O-角度上的WEB-API粒度" class="headerlink" title="I/O 角度上的WEB API粒度"></a>I/O 角度上的WEB API粒度</h2><p>记得以前写web api的时候，在controller层面会要求尽量精简，一般只会做外部参数校验，然后具体功能是对service层的转发，service层包含业务逻辑，会是一些更基础服务的组合。<br>这样做的一个好处是，如果service层的功能A需要调用到功能B，无需走网络I/O，可以直接走内存。  </p>
<p>下表是不同 I/O 类型及其对应的开销(摘录自《深入浅出node.js》P48)</p>
<table>
<thead>
<tr>
<th style="text-align:left">I/O 类型</th>
<th style="text-align:left">花费的 CPU 时钟周期</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CPU 一级缓存</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">CPU 二级缓存</td>
<td style="text-align:left">14</td>
</tr>
<tr>
<td style="text-align:left">内存</td>
<td style="text-align:left">250</td>
</tr>
<tr>
<td style="text-align:left">硬盘</td>
<td style="text-align:left">41000000</td>
</tr>
<tr>
<td style="text-align:left">网络</td>
<td style="text-align:left">240000000</td>
</tr>
</tbody>
</table>
<blockquote>
<p>到这里，有一个很有意思的问题，假如我们访问的是 127.0.0.1 那么时钟周期是在什么级别？</p>
</blockquote>
<hr>
<h2 id="API功能单一化（降低API粒度）"><a href="#API功能单一化（降低API粒度）" class="headerlink" title="API功能单一化（降低API粒度）"></a>API功能单一化（降低API粒度）</h2><p>一个函数所做的事情越多，那么它出错的概率就越大。<br>比如发送操作，最基础的版本是这样的<br><code>1) 获取要发送的用户</code> -&gt; <code>2) 匹配文案</code> -&gt; <code>3) 调用第三方推送服务</code><br>但是有一天，产品告诉你，有用户收不到，所以你加了个重试<br><code>1) 获取要发送的用用户</code> -&gt; <code>2) 匹配文案</code> -&gt; <code>3) 调用第三方推送服务</code> -&gt; <code>4) 判断返回，失败重试</code><br>平稳了一段时间，后来接入的业务多了，发现超过第三方推送服务的频率限制了，于是在（3）处加了个延时，似乎曲线救国了。<br>后来，运营来了，我有一个n万的名单要发。。。结果。。。<br>事实上，真实的推送，比这复杂得多。还得考虑app版本，用户推送设置，多app的证书问题，第三方接口频率限制问题，任务定时，错误怎么处理等~~~</p>
<p>我们无法保证程序是100%可靠的，所以要想办法降低出错后的成本。一个思路是，单个函数只做一件事，单个函数只处理单个任务，不做批量处理，通过并发实现产能的提高（提高并发，其实就是水平拓展）。  </p>
<p>比如拆分后的发送模型<br><img src="http://image-2.plusman.cn/image/push-send-model.png" alt="发送模型"><br>现在的频率限制可以放在右侧的消费 worker 上。<br>实际测试中，最后的推送操作事故率是最高的，而任务添加的操作，相比而言是轻量的，通过 Watcher 隔离后，尽量保证业务方的不受影响。</p>
<p>worker 消费任务的时候，每次只取一条，发生未知错误后，worker 会终止运行，这时候需要人工介入。这样做，即使 worker 挂了，大多数任务还在任务池，没有随着内存烟消云散了，排查完错误后，还有得救。</p>
<p>那么定时任务如何实现呢，本着功能单一的原则，不会往发送模型上去加。<br><img src="http://image-2.plusman.cn/image/push-schedule-model.png" alt="任务模型"><br>订阅列表的出现，是为了解决群发时用户状态遍历耗时的瓶颈。</p>
<p>在这次重构中，API功能单一化，除了降低了出错后的损失外，还为后期的拓展带来了可能性，比如把一个消费worker变成一台机器，就可以实现集群了。</p>
<hr>
<h2 id="为什么需要Worker"><a href="#为什么需要Worker" class="headerlink" title="为什么需要Worker"></a>为什么需要Worker</h2><p>node 从0.8开始，引入了 cluster 模块，程序员可以借此轻松的创建多进程应用，搭建单机集群。多进程架构除了能够更加高效的利用CPU资源外，还能更好的保证服务可用性。<br>对于web服务，我们经常通过 cluster 开启一个主进程和多个子 worker，每个 worker 都拥有完整的功能，然后通过端口复用实现负载均衡。<br>由于各个 worker 之间是相互独立的，所以只要主进程没挂，且至少有一个子worker存活，就可以继续提供服务。<br>更进一步的做法是，针对每个web api起独立的worker，该worker仅拥有该web api需要的功能，这种更加精细化的操作，就要用到 node 的 <code>child_process</code> 模块了,但是 node 官方文档里面有这么一句  </p>
<blockquote>
<p>These child Node.js processes are still whole new instances of V8. Assume at least 30ms startup and 10mb memory for each new Node.js. That is, you cannot create many thousands of them.</p>
</blockquote>
<p>所以，这是把双刃剑，一旦 worker 数目失控，不能有效的回收，那就机毁人亡了。  </p>
<hr>
<h2 id="Worker-管理"><a href="#Worker-管理" class="headerlink" title="Worker 管理"></a>Worker 管理</h2><p>本来想写在这里，发现没有示例，容易变成说明书，<br>打算配合示例，另起一篇，打算说说</p>
<ul>
<li>worker 启动和回收</li>
<li>worker 之间的通信</li>
<li>worker 之间的隔离</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[(node性能优化一) API响应时间监测]]></title>
      <url>http://plusman.cn/2016/01/05/b3-node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-API%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E7%9B%91%E6%B5%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Written with <a href="http://www.vim.org/" target="_blank" rel="external">vim</a></p>
</blockquote>
<hr>
<p><img src="http://image-2.plusman.cn/image/cheniu-api-time-line.png" alt="cheniu-api-time-line.png"><br>古语：“知己知彼，百战不殆”，面对性能优化，哪怕不求百战不殆，也求“死得明白”，所以在尝试进行系统性能优化之前，先得了解系统的性能瓶颈在哪，不至于使不上劲。</p>
<blockquote>
<p>我不生产知识，只是知识的搬运工，都是团队实践的总结。</p>
</blockquote>
<a id="more"></a>
<h2 id="监控选型：Grafana-Telegraf-InfluxDB"><a href="#监控选型：Grafana-Telegraf-InfluxDB" class="headerlink" title="监控选型：Grafana + Telegraf + InfluxDB"></a>监控选型：Grafana + Telegraf + InfluxDB</h2><p>选型是团队的架构湿安叔做的，考虑到数据实时性和灵活性，选择了<a href="http://grafana.org/" target="_blank" rel="external">Grafana</a>（下文简称Gra）  和 <a href="https://influxdata.com/" target="_blank" rel="external">InfluxDB</a>（下文简称Inf）， 与 <a href="http://www.oneapm.com/" target="_blank" rel="external">oneapm</a> 互补。</p>
<ul>
<li>Inf是 time-series data 类型的数据库，支持类sql语句查询，适合监控数据存储，实时分析。</li>
<li><a href="https://influxdata.com/time-series-platform/telegraf/" target="_blank" rel="external">Telegraf</a> 是安装于生产机的守护进程，用于埋点数据收集并转发到Gra数据库，并收集宿主机负载信息</li>
<li>Gra 用作数据呈现，封面截图就来自Gra</li>
</ul>
<p>实践环境：</p>
<ul>
<li>node v4.2.3</li>
<li>Ubuntu 14.04，15.04</li>
<li>Express v3.4.7 ~ v4.13.3</li>
</ul>
<h2 id="step1：安装InfluxDB"><a href="#step1：安装InfluxDB" class="headerlink" title="step1：安装InfluxDB"></a>step1：安装InfluxDB</h2><p>1）下载和安装<br>传送<a href="https://influxdata.com/downloads/" target="_blank" rel="external">InfluxDB - Database Download</a>，直接找到 Ubuntu &amp; Debian 章节，按照提示安装，相比于apt-get方法，此法在国内特殊环境下靠谱些。<br>2）启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service influxdb start</div></pre></td></tr></table></figure></p>
<p>3）检查服务是否启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo netstat -apn | grep 8086</div></pre></td></tr></table></figure></p>
<p>看到如下结果，代表启动正常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp6  0  0 :::8086    :::*   LISTEN  1746/influxd</div></pre></td></tr></table></figure></p>
<h2 id="step2：安装Telegraf"><a href="#step2：安装Telegraf" class="headerlink" title="step2：安装Telegraf"></a>step2：安装Telegraf</h2><p>1）下载和安装<br>传送<a href="https://influxdata.com/downloads/#telegraf" target="_blank" rel="external">Telegraf - Data Collector Download</a>，通InfluxDB，按照提示安装即可。<br>2）配置文件<br>安装完成后，Linux debian and RPM packages 的配置文件位置在 <code>/etc/opt/telegraf/telegraf.conf</code><br>打开文件后，发现 SERVICE PLUGINS 是空的，我们需要安装 <a href="https://github.com/influxdata/telegraf/tree/master/plugins/statsd" target="_blank" rel="external">statsd</a>，Telegraf 命令的位置在 <code>/opt/telegraf/telegraf</code><br>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/telegraf/telegraf -usage statsd</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># Statsd Server</div><div class="line">[[plugins.statsd]]</div><div class="line">  # Address and port to host UDP listener on</div><div class="line">  service_address = &quot;:8125&quot;</div><div class="line">  # Delete gauges every interval (default=false)</div><div class="line">  delete_gauges = false</div><div class="line">  # Delete counters every interval (default=false)</div><div class="line">  delete_counters = false</div><div class="line">  # Delete sets every interval (default=false)</div><div class="line">  delete_sets = false</div><div class="line">  # Delete timings &amp; histograms every interval (default=true)</div><div class="line">  delete_timings = true</div><div class="line">  # Percentiles to calculate for timing &amp; histogram stats</div><div class="line">  percentiles = [90]</div><div class="line"></div><div class="line">  # templates = [</div><div class="line">  #     &quot;cpu.* measurement*&quot;</div><div class="line">  # ]</div><div class="line"></div><div class="line">  # Number of UDP messages allowed to queue up, once filled,</div><div class="line">  # the statsd server will start dropping packets</div><div class="line">  allowed_pending_messages = 10000</div><div class="line"></div><div class="line">  # Number of timing/histogram values to track per-measurement in the</div><div class="line">  # calculation of percentiles. Raising this limit increases the accuracy</div><div class="line">  # of percentiles but also increases the memory usage and cpu time.</div><div class="line">  percentile_limit = 1000</div></pre></td></tr></table></figure></p>
<p>将配置示例复制到 SERVICE PLUGINS 下方。<br>statsd 允许其他应用通过udp的方式，以特定语法向Telegraf传递应用数据。<br>3）开启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service telegraf start</div></pre></td></tr></table></figure></p>
<p>4）检查服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo netstat -apn | grep 8125</div></pre></td></tr></table></figure></p>
<p>输出如下，代表启动正常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udp6  0  0 :::8125   :::*  2696/telegraf</div></pre></td></tr></table></figure></p>
<h2 id="step3：-应用埋点-以-Express-为示例"><a href="#step3：-应用埋点-以-Express-为示例" class="headerlink" title="step3： 应用埋点-以 Express 为示例"></a>step3： 应用埋点-以 Express 为示例</h2><blockquote>
<p>应用埋点，其实就是向Telegraf的Statsd服务发送数据包，端口是8125</p>
</blockquote>
<p>在需找中间件的过程中，发现了 <a href="https://github.com/uber/express-statsd" target="_blank" rel="external">Uber express-statsd</a>，README.md 内给出了一种埋点方法  <a href="https://github.com/uber/express-statsd#per-route-example" target="_blank" rel="external">传送门</a><br>推荐的方法是在路由定义时就需要确定这个API对应的Key，但是实际情况是，我参与的项目已经有几十万行的代码量，大量路由已经定义过，不可能再去动这些路由。<br>当时尝试的第一种方式，req.statsdKey 为 req.url，然而url是动态的，随便加个参数就不同了，会产生大量无用key，而且并没有按照API进行有效的聚合，尤其是GET类型的请求。<br>尝试的的第二种方式，req.path 为 key，但是碰到 path url 样式的路由就会和 req.url 发生一样的状况，例如 <code>/get/user/:id</code>。<br>接着尝试第三种方式<br>先脱离Express，回到最基础 node 内置模块 http，以前我们要开启一个http服务器，会这样书写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">http.createServer(function(req,res)&#123;</div><div class="line">  res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html; charset=utf-8&apos;&#125;);</div><div class="line">  /**</div><div class="line">    中间对URL做判断，输出不同结果；判断的过程其实就是Express的route</div><div class="line">  */</div><div class="line">  res.end(req.url + &apos; at time &apos; + Date.now() + &apos; \n&apos;);</div><div class="line">&#125;).listen(9002);</div></pre></td></tr></table></figure></p>
<p>所以，<code>var app = express()</code>，如果去看app的类型，其实就是个Function，我们在app上绑定上一堆中间件后，最后会执行这么一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.createServer(app).listen(PORT);</div></pre></td></tr></table></figure></p>
<p>所以尝试把焦点放到 Express 的路由机制上，假设 Express 最后处理了一个请求并且有返回，那么在请求结束的时候，req 对象上应该会存有匹配到的路由的信息，因为路由信息是确定的，所以可以作为key，而且可以保证请求按照API进行聚合。<br>首先确定，一次请求在什么时候结束，查阅文档发现，http 模块内 的res 对象有 finish，close，error  事件，用之。<br>再去获取 req 对象上的路由信息，通过 debug 模式发现了 Express 在 req 对象上绑定了 route 对象，保存了请求匹配的路由信息。<br>综上，改写了 <a href="https://github.com/plusmancn/express-statsd-route" target="_blank" rel="external">express-statsd-route</a> 这个模块，具体使用方法可查看项目README。</p>
<blockquote>
<p>检查埋点是否成功</p>
</blockquote>
<p>Command shell 连接到InfluxDB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">influx</div></pre></td></tr></table></figure></p>
<p>在shell内执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 选择 telegraf 数据库</div><div class="line">USE telegraf</div><div class="line"># 显示所有统计字段，检查埋点key是否存入</div><div class="line">SHOW MEASUREMENTS</div></pre></td></tr></table></figure></p>
<h2 id="step4：安装Grafana"><a href="#step4：安装Grafana" class="headerlink" title="step4：安装Grafana"></a>step4：安装Grafana</h2><p>传送 <a href="http://docs.grafana.org/installation/debian/#install" target="_blank" rel="external">Installing on Debian / Ubuntu</a><br>1）开启服务<br>配置位置：<code>/etc/grafana/grafana.ini</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service grafana-server start</div></pre></td></tr></table></figure></p>
<p>命令执行成功后，将在 3000 端口开启http服务，浏览器访问 <code>http://your_ip:3000</code></p>
<p>2）添加InfluxDB支持<br>直接使用系统默认帐号 admin/admin 登入系统，添加 <a href="http://docs.grafana.org/datasources/influxdb/" target="_blank" rel="external"> Data Sources InfluxDB</a>。<br>配置完毕后，添加一个DashBoard，按照提示选择需要呈现的数据和纬度。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>完成上述操作后，稍作配置就可以得到类似封面图的效果啦。<br>接下来</p>
<ul>
<li>针对外部服务的性能消耗统计</li>
<li>整理一些 Grafana 针对 InfluxDB 的常用统计语句</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2015年末总结]]></title>
      <url>http://plusman.cn/2016/01/04/b2-2015%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Written with <a href="http://www.vim.org/" target="_blank" rel="external">vim</a></p>
</blockquote>
<hr>
<p><img src="http://image-2.plusman.cn/image/拖油瓶的小男孩.jpg" alt="拖油瓶的小男孩"></p>
<p>“浮躁”是过去一年的基调。</p>
<p>2015经历了创业失败、毕业、应聘第一份正式工作，一切都来得很快，在冲动和被动中前行。</p>
<a id="more"></a>
<p>关于“创业”，其实自己都不确定那算不算一次创业，虽然是自己的idea，也是自己把产品从0做到了1，但从始至终。对于技术以外的东西，没有任何兴趣，当然一夜暴富的想法除外。后来，退出了这场创业。现在还时不时有人提起那段往事，但内心慢慢也看淡了许多，或许我只是想做个好玩的东西，就像个geek一样，而不是创业。面对资本、世故，我还显稚嫩，这一场过后，自己踏实了很多。</p>
<p>后来有一场短暂的初创公司的实习之旅，七月份毕业后，面对松散的团队，内心是惶恐的。仗着项目经验，信心满满的去面试了几家大公司，结果100%卡壳基础知识轮，这才明白，自己的技术是做得多轻浮，静下心来，默默的补了一个月基础知识。</p>
<p>8月是今年的一个分割点，纠结好久投了一份简历给芋头，投完很不是自信，半夜爬起又补发了一句，说道，自己基础还太薄弱，不想浪费来之不易的面试机会，等以后准备好了再来。没想到头哥居然回复我了，说他对应届生更加看重的是成长空间和技术热情。当时没多想，就回了句，“从未怀疑过自己对技术的热情，我想试试”。</p>
<p>这句话，也确实是大学四年的写照，热情是有，但更多的是浮于表面，浅尝则止。<br>来到大搜车后，幸运地坐在头哥工位旁边，开始面对远远比过去复杂得多的项目，当时的感受是面对着一个黑盒，无从下手。去尝试剖析这个黑盒成了这小半年的主旋律。<br>那时写完代码一上线，就感觉像是风筝断了线，当线上一旦出现问题需要排查的时候，会有深深的无力感，因为线上系统还没有一个完善的错误收集和性能监控模块。<br>利用空闲尝试做了一些这方面的工作，无奈宥于视野和基础知识，目前仅仅利用sentry实现了错误栈上传，12月份参加D2，听了QZone的日志收集方案，其中关于按请求和用户聚合的思路，准备在2016年实践下。</p>
<p>搜车的前端团队对新事物的吸收能力特别强，react、angular、web component、Flux等各种新技术都有被分享和实践。面对如此多的新事物，这小半年个人还是选择了坚持补node、javascript方面的基础知识，因为没有根基的大厦，风一吹就倒了。明年会选择性的尝试阅读几个框架的源码，感受下大师们的编程思想。对于流行框架，还是持需要才知道的态度。</p>
<p>对于2016年，希望</p>
<ul>
<li>对于node程序性能优化、线上集群监控、错误收集不再有心无力</li>
<li>努力多赚点，存点小钱，准备人生大事</li>
<li>学会享受每一个过程，工作、生活、旅行。</li>
<li>把博客坚持下来。</li>
<li>对女朋友好好好好好很多，争取得到5星好评</li>
</ul>
<p>最最重要的是，2016年更加踏实点～～～</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于Error对象继承的几点疑惑]]></title>
      <url>http://plusman.cn/2015/12/11/b6-prototype-chain/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Written with <a href="http://www.vim.org/" target="_blank" rel="external">vim</a></p>
</blockquote>
<hr>
<blockquote>
<p>疑惑来自对Error对象的继承</p>
</blockquote>
<p>某段业务代码里面的错误定义形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var BadRequest = function(msg, code) &#123;</div><div class="line">    this.name = &apos;BadRequest&apos;;</div><div class="line">    this.message = msg || &apos;BadRequest&apos;;</div><div class="line">    this.code = code || null;</div><div class="line">    Error.call(this, msg);</div><div class="line">    Error.captureStackTrace(this, arguments.callee); /* 是否多余 */</div><div class="line">&#125;;</div><div class="line">BadRequest.prototype.__proto__ = Error.prototype;</div><div class="line">Error.badRequest= function(msg, code) &#123;</div><div class="line">    return new BadRequest(msg, code);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>疑惑</p>
<ol>
<li><code>__proto__</code>  直接赋值做原型链继承，是否存在隐患</li>
<li>Error.captureStackTrace 是否多余</li>
</ol>
<hr>
<a id="more"></a>
<blockquote>
<p>针对疑惑1，搜索了node中stream模块继承的示例代码</p>
</blockquote>
<p>1）node中大量模块继承自events，以stream模块为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 有省略</div><div class="line">module.exports = Stream;</div><div class="line">const EE = require(&apos;events&apos;);</div><div class="line">util.inherits(Stream, EE); // 原型链继承</div><div class="line">function Stream() &#123;</div><div class="line">  EE.call(this); // 构造函数方法继承</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于原型链的继承，尝试探究Stream的Prototype属性，跟踪进入util.inherits 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 摘自 node 5.0.0 +  lib/util.js 中 exports.inherits 方法</div><div class="line">Object.setPrototypeOf(ctor.prototype, superCtor.prototype);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 摘录自 node 0.12 系列，lib/util.js 中 exports.inherits 方法</div><div class="line">ctor.prototype = Object.create(superCtor.prototype, &#123;</div><div class="line">  constructor: &#123;</div><div class="line">    value: ctor,</div><div class="line">    enumerable: false,</div><div class="line">    writable: true,</div><div class="line">    configurable: true</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ctor是Stream对象，superCtor是EE对象，操作完成后，Stream的原型链呈现如下关系<br><img src="http://7xnts0.dl1.z0.glb.clouddn.com/image/继承-原型链关系图-v1.png" alt="继承-原型链关系图.png"></p>
<p>结合原型链向上搜索的特性，Stream模块可以通过<code>__proto__</code>指针访问到EventEmitter.prototype上的方法，如果对象的<code>__proto__</code>指针为null，则停止搜索。<br><code>Object.prototype.__proto__</code> 指针为null，Object是JS中所有对象类型的源头。</p>
<blockquote>
<p>所以，<code>__proto__</code>直接赋值，做原型链继承，从操作结果上来看，是没有问题的。</p>
</blockquote>
<hr>
<p>还有另外几种常见的原型链继承的方法对比</p>
<p>方式1，引自<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error#.E7.A4.BA.E4.BE.8B.3A_.E8.87.AA.E5.AE.9A.E4.B9.89.E5.BC.82.E5.B8.B8.E7.B1.BB.E5.9E.8B" target="_blank" rel="external">Error MDN</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctor.prototype = Object.create(superCtor.prototype);</div><div class="line">// ctor.prototype.constructor = ctor; // 假如我们注释了这步</div></pre></td></tr></table></figure></p>
<p>再看下原型链图（注释了 ctor.prototype.constructor = ctor），<a href="https://jsfiddle.net/plusman/gdeake7c/39/" target="_blank" rel="external">测试代码</a><br><img src="http://7xnts0.dl1.z0.glb.clouddn.com/image/Object.create-原型链继承.png" alt="Object.create-原型链继承"></p>
<p>另外一种写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctor.prototype = new superCtor();</div></pre></td></tr></table></figure></p>
<p>对应的原型链图 <a href="https://jsfiddle.net/plusman/gdeake7c/40/" target="_blank" rel="external">测试代码</a><br><img src="http://7xnts0.dl1.z0.glb.clouddn.com/image/new-原型链继承.png" alt="new-原型链继承"></p>
<blockquote>
<p>几种方式<code>__proto__</code>最后的指向都相同，但是后两种方法Stream对象的constructor发生了变化，这里碰到了一个问题，假如Stream的constructor指向自己，那么EventEmitter构造函数的方法将丢失，如何既保留Stram的构造函数方法，又拥有父类的构造函数方法，就牵涉到继承的另一个层面，构造函数方法的继承。</p>
</blockquote>
<p>首先可以确定一点，Stream的constructor肯定要指向自己(ctor.prototype.constructor = ctor)，然后再在function Stream里面想办法执行function EventEmitter的方法。但是，面对传参数问题，很难有一种统一的方法。<br>1）传空参数给父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function ctor()&#123;</div><div class="line">  superCtor.call(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2）所有参数继续传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function ctor(arg1, arg2)&#123;</div><div class="line">  superCtor.apply(this, arguments);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3）参数经过处理后，继续传递，毕竟superCtor能接受的参数，和ctor总会有不同的时候。</p>
<p>所以，node里面的util.inherits方法，只做了原型链继承，构造函数方法继承或不继承、如何继承，全交于程序员自由发挥。<br>但是在ES6的标准类实现里面，子类必须继承父类的constructor方法，参见阮一峰的<a href="http://es6.ruanyifeng.com/#docs/class#Class的继承" target="_blank" rel="external">class继承</a>，但是不管是ES2015还是ES5，本质上都是基于原型链的继承。</p>
<hr>
<blockquote>
<p>回到疑惑2，Error对象的继承里面，Error.captureStackTrace 是否多余</p>
</blockquote>
<p>第一反应查看Error对象，但是显示<code>function Error() { [native code] }</code>是v8的代码，那就先当黑盒处理。<br>1）先注释掉 captureStackTrace 方法，<a href="https://jsfiddle.net/plusman/gdeake7c/45/" target="_blank" rel="external">示例代码</a><br>发现stack对象为空。<br>2）保留 captureStackTrace，删除 Error.call(this, msg),<a href="https://jsfiddle.net/plusman/gdeake7c/47/" target="_blank" rel="external">示例代码</a><br>得到了stack对象。</p>
<blockquote>
<p>所以如果我们需要错误对象拥有错误栈的话，需要使用 Error.captureStackTrace 从v8截获。</p>
</blockquote>
<p>查阅node文档<br>Creates a .stack property on targetObject, which when accessed returns a string representing the location in the program at which Error.captureStackTrace was called.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;&#125;;</div><div class="line">Error.captureStackTrace(myObject);</div><div class="line">myObject.stack  // similar to `new Error().stack`</div></pre></td></tr></table></figure></p>
<p>不难理解captureStackTrace 会把错误栈绑定绑定在对象的stack属性上，最后一句注释<code>similar to new Error().stack</code>引起了疑惑。</p>
<blockquote>
<p>如果 new Error().stack 就可以获取到stack，那么 Error.call(this, msg)，为什么不能。</p>
</blockquote>
<p>确认下，new 操作符号会做那些事  </p>
<ol>
<li>新建一个实例对象，内部用this指代，并调用对象的constructor方法</li>
<li>将对象的prototype属性，挂载到实例对象的<code>__proto__</code>上</li>
</ol>
<p>鉴于1，Error.call(this, msg)，有调用Error的constructor方法，按道理，stack会被挂载到this对象上，但是没有。</p>
<p>尝试查看Error对象的源码定义，无奈没找到；后来回想stack未必一定挂载在this对象上，也可以挂载在<code>__proto__</code>属性上，这样同样可以通过<code>new Error().stack</code>访问到，因为原型链向上搜索的特性。</p>
<blockquote>
<p>所以，如果需要保留错误栈，文章开头那段，Error.captureStackTrace 还是需要保留的。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[15年11月总结]]></title>
      <url>http://plusman.cn/2015/11/30/b1-15%E5%B9%B411%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
<p><img src="http://7xnts0.dl1.z0.glb.clouddn.com/0K21211R_0.png" alt="disappointed &amp; hope"></p>
<h2 id="Part1-Disappointed-amp-Hope"><a href="#Part1-Disappointed-amp-Hope" class="headerlink" title="Part1 Disappointed &amp; Hope"></a>Part1 Disappointed &amp; Hope</h2><p>1）2015-11-15 21:26:12<br>最近不太敢去写代码，编程似乎一直停留在if/else。想写RESTFUL API SDK封装，想啊想，一个request网络库加一些结构化的配置，再加一个工厂函数，再加一些基础测试、性能测试，然后日后多加维护，似乎也想不出什么新意了。写的代码似乎没有了灵魂。<br>于是，害怕写代码，面对写下每一行都熟悉的代码，想问出个为什么要这样写，奈何眼界狭隘，思而不得。<br><a id="more"></a><br>下午听到大学几个朋友在beta咖啡讲Linux源码解析，就过去凑热闹。<br>大概记得讲了</p>
<ul>
<li>页目录、页表、内存之间的映射关系，</li>
<li>Linux源码内存初始化，进程fork的本质。</li>
<li>还有线程和进程原理上的解释。</li>
</ul>
<p>关于线程和进程，想起了朴大大的一句话，大概意思如下，面对线程和进程都不理解的人，没必要麻烦的打一堆比方去让其明白，一个写程序的人，这是编程的基础。然而，到现在我还真的不知道，<br>华哥说，当时他有一段时间也怀疑自己写的每一句代码，后来他选择了看更加基础和底层的知识，比如去阅读Nginx源码，Linux源码，去解答自己的疑惑。<br>以前自己也常说，编程是一种思想，语言只是一种实现工具，后来也听过很多大大也这么说，但思想的根基是什么，没人告诉我，所以似乎现在的我，也没有什么思想，语言倒是切换了很多门。<br>今天，有了一点点感悟，思想的根基是扎实的基础，具体点如，Linux系统的构成，内核源码剖析，数据结构，一些数学模型和算法；引爆思想的导火索，应该还是具体的需求，比如大数据分析的需求，恐怕现在只有BAT那种体量的公司才会有。<br>华哥举了个例子，说在他管理的一片机器集群里，有一次做了内核升级后，一些机器的Load抽风性的飙到满负荷。于是，他就给所有机器加了告警通知，然后不管半夜还是啥时候，一旦发现问题，立马ssh上去查证，然而很多时候，还没等连接上去，事故现场已经消失了。<br>后来，他们部门的一个女生也碰到了类似问题，但是她没有选择加告警的方式，而是统计所有机器的负载随着时间变化的情况，然后再去统计相关的业务特征、机器特征、内核系统特征，然后进行统计学和概率论的分析，最后当然解决了问题。<br>这或许就是一种由数学为基础、需求引导出来的思想，换做自己肯定也就是加个日志报错，扮演救火队员的角色，几台机器还救得过来，成千上万台呢？当然我还没有那种需求。<br>回归现实，面对现在的瓶颈，我能做些什么，先做好这几点吧，看看能不能有什么成长。</p>
<ul>
<li>回顾下几种基础的数据结构</li>
<li>至少从原理上理解线程和进程吧</li>
<li>好痛苦，为什么我会觉得Linux软件这么难装，编译和包依赖，到底如何解决，能不能有一天能够愉快的装上自己要装的软件，出了问题，除了看报错，还能有哪些方面可以怀疑。</li>
<li>LintCode一周一题，要求很低很低了。。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS时间处理]]></title>
      <url>http://plusman.cn/2015/08/10/b5-JS%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
<hr>
<h2 id="ISO-8601-计时法"><a href="#ISO-8601-计时法" class="headerlink" title="ISO 8601 计时法"></a>ISO 8601 计时法</h2><p><a href="http://zh.wikipedia.org/w/index.php?title=ISO_8601&amp;_=20150605114027" target="_blank" rel="external">ISO 8601</a>计时法规定，<code>2015-06-05T12:33:51.012Z</code> 末尾的Z代表UTC时间，且时间内需要带有前导0（6需要写成06）。UTC代表世界协调时间，即0号时区，约等于格林尼治事件，上面的时间还可以表示为<code>2015-06-05T12:33:51.012+0000</code>；<br>天朝的北京时间（东8区），如果上面的时间表示为北京时间的话 <code>2015-06-05T20:33:51.012+0800</code>。<br>注意上面关键词是转换，上面两个时间是同一个时间的不同表述方法而已。<br>Ps:<br>因为地球是自西向东转的，所以我们比西边的人，早看到太阳，所以要+0800 （地理：读者视角，看地图，上北下南左西右东）<br><img src="http://7xnts0.dl1.z0.glb.clouddn.com/445158-b53bcbcb2f0ff4f8.jpg" alt="地球转向，自西向东"></p>
<hr>
<a id="more"></a>
<h2 id="8小时时差的由来"><a href="#8小时时差的由来" class="headerlink" title="8小时时差的由来"></a>8小时时差的由来</h2><p>时间缺少时区标识符 &amp;&amp; 服务器和客户端默认时区不同造成。<br>如 <a href="https://leancloud.cn/docs/cloud_code_guide.html#%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="external">LeanCloud 云代码8小时时差问题</a><br>看一段示例代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="keyword">var</span> localeTime = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-12T12:00:00.000'</span>); <span class="comment">// 1-12 需要写成01-12，表达式也等于 var localeTime = new Date('2015-01-12T12:00:00.000Z);</span></div><div class="line"><span class="built_in">console</span>.log(localeTime.toISOString());<span class="comment">//output 2015-01-12T12:00:00.000Z，ISO 8601 时间</span></div><div class="line"><span class="built_in">console</span>.log(localeTime.toLocaleString()); <span class="comment">//output 1/12/2015, 8:00:00 PM // 转换为当地时间，此处为东8区，+8小时。</span></div></pre></td></tr></table></figure></p>
<p>缺少时区标识，如果在同一个运行环境下执行，本身也没有什么问题，但是假设，服务器的时区设置为0时区（UTC时间），浏览器设置是东8区时间。<br>用户浏览器时区是东8区，生成时间 2015-01-12 12:00:00.000，<br>通过 new Date(‘2015-01-12 12:00:00.000’)存入数据库后，最后存储对象实际是 2015-01-12T12:00:00.000Z，转换为东8区后，实际是，2015-01-12T20:00:00.000Z。</p>
<p><strong>如果时间是在服务器上处理成字符串后传给浏览器的，浏览器视觉上看上去是对的；但是，如果把2015-01-12T12:00:00.000Z直接交给浏览器处理，在经由new Date，就会比预期多出8小时。</strong></p>
<hr>
<h2 id="如何规避时区问题"><a href="#如何规避时区问题" class="headerlink" title="如何规避时区问题"></a>如何规避时区问题</h2><p><strong>客户端在给服务器传送时间的时候，带上时区标识；同理，服务器回传的时候，也需要带上时区标识</strong><br>通过下列代码可以获取到当前所在时区，然后进行字符串拼接<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line">- <span class="keyword">new</span> <span class="built_in">Date</span>().getTimezoneOffset()/<span class="number">60</span> <span class="comment">// output 8，东8区</span></div></pre></td></tr></table></figure></p>
<p>如果获取当前时间，可以简单的使用如下写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().toISOString(); <span class="comment">//获取当前时间</span></div></pre></td></tr></table></figure></p>
<p>传递完整的时间信息，让最终的接收端去做最后的时间处理，可以实现时间的本地化（设备可以获取到当前时区）；<br>更多的好处是，时间格式可以用更加友好的形式展现给用户，不会受困于地区和国家的变化。<br><strong>尝试使用 <a href="http://momentjs.com/timezone/" target="_blank" rel="external">moment-timezone</a></strong><br>文档很完善，node &amp;&amp; browser support.</p>
<hr>
<h2 id="时间格式化函数"><a href="#时间格式化函数" class="headerlink" title="时间格式化函数"></a>时间格式化函数</h2><p>参考了网上现有的<a href="http://yaniswang.com/frontend/2013/02/16/dateformat-performance/" target="_blank" rel="external">JS日期时间格式</a>函数，综合性能和易用性，采用拓展原生Date prototype，添加format方法，添加格式化参数引号内字符串不解析特性，示例如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="comment">/** </span></div><div class="line"> * 对日期进行格式化， </div><div class="line"> * @param date 要格式化的日期 </div><div class="line"> * @param format 进行格式化的模式字符串</div><div class="line"> *     支持的模式字母有： </div><div class="line"> *     y:年, </div><div class="line"> *     M:年中的月份(1-12), </div><div class="line"> *     d:月份中的天(1-31), </div><div class="line"> *     H:小时(0-23), </div><div class="line"> *     m:分(0-59), </div><div class="line"> *     s:秒(0-59), </div><div class="line"> *     S:毫秒(0-999),</div><div class="line"> *     q:季度(1-4)</div><div class="line"> * @return String</div><div class="line"> * @author plusmancn@gmail.com</div><div class="line"> *</div><div class="line"> *  使用示例</div><div class="line"> *  new Date().format('yyyy-MM-dd HH:mm:ss "season" q'); // 2015-06-07 11:mm:17 season 2</div><div class="line"> *  new Date().format("yyyy-MM-dd HH:mm:ss 'season' q"); // 2015-06-07 11:mm:17 season 2</div><div class="line"> *  new Date().format('yyyy-MM-dd HH:mm:ss 季度：q'); // 2015-06-07 11:mm:17 季度：2</div><div class="line"> *  new Date().format('yyyy-MM-dd HH:mm:ss "季度："q'); //2015-06-07 11:mm:17 02 </div><div class="line"> *  // 存在Bug，不能在内部引号后紧跟标识符，中文可以通过第三个示例解决，英文单词间一般都有空格，所以影响不大。</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="built_in">Date</span>.prototype.format = <span class="function"><span class="keyword">function</span>(<span class="params">fmt</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="string">'y'</span>:<span class="keyword">this</span>.getFullYear(),</div><div class="line">    <span class="string">'M'</span>:<span class="keyword">this</span>.getMonth() + <span class="number">1</span>,</div><div class="line">    <span class="string">'d'</span>:<span class="keyword">this</span>.getDate(),</div><div class="line">    <span class="string">'H'</span>:<span class="keyword">this</span>.getHours(),</div><div class="line">    <span class="string">'m'</span>:<span class="keyword">this</span>.getMinutes(),</div><div class="line">    <span class="string">'s'</span>:<span class="keyword">this</span>.getSeconds(),</div><div class="line">    <span class="string">'S'</span>:<span class="keyword">this</span>.getMilliseconds(),</div><div class="line">    <span class="string">'q'</span>:<span class="built_in">Math</span>.floor((<span class="keyword">this</span>.getMonth() + <span class="number">3</span>) / <span class="number">3</span>),</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> fmt.replace(<span class="regexp">/('.*'|".*"|[yMdHmsSq])+/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">all,p</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (p === <span class="string">'y'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> (<span class="string">''</span> + o[<span class="string">'y'</span>]).substr(<span class="number">4</span>-all.length);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!!o[p])&#123;</div><div class="line">      <span class="keyword">var</span> v = <span class="string">''</span>+o[p];</div><div class="line">      <span class="keyword">return</span> (<span class="string">'0'</span>+v).substr(-v.length + (v.length &lt; <span class="number">2</span> &amp;&amp; all.length &gt; <span class="number">1</span>?<span class="number">-1</span>:<span class="number">0</span>));</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> all.replace(<span class="regexp">/['"]/g</span>,<span class="string">''</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="奇异的特性"><a href="#奇异的特性" class="headerlink" title="奇异的特性"></a>奇异的特性</h2><h3 id="12-00-PM-还是-1-00-PM-哪个时间大"><a href="#12-00-PM-还是-1-00-PM-哪个时间大" class="headerlink" title="12:00 PM 还是 1:00 PM 哪个时间大"></a>12:00 PM 还是 1:00 PM 哪个时间大</h3><p>事实总是不是你看到的这样，js做了取余操作，12 % 12 =0<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1/12/2015, 12:00:00 PM'</span>).getTime() - <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1/12/2015, 1:00:00 PM'</span>).getTime()); <span class="comment">// output  -3600000</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1/12/2015, 12:00:00 PM'</span>).getTime()); <span class="comment">// 1421035200000</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1/12/2015, 00:00:00 PM'</span>).getTime()); <span class="comment">// 1421035200000</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1/12/2015, 1:00:00 PM'</span>).getTime());  <span class="comment">// 1421038800000</span></div></pre></td></tr></table></figure></p>
<h3 id="前导0的8小时时差"><a href="#前导0的8小时时差" class="headerlink" title="前导0的8小时时差"></a>前导0的8小时时差</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">new Date(&apos;2015-01-1&apos;)</div><div class="line">Thu Jan 01 2015 00:00:00 GMT+0800 (CST)</div><div class="line">new Date(&apos;2015-01-01&apos;)</div><div class="line">Thu Jan 01 2015 08:00:00 GMT+0800 (CST)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
