---
title: '剖析 JS 内 0.1 + 0.2 = 0.30000000000000004 计算失精问题'
date: '2017-05-01 22:35:38'
tags:
- '基石'
---

## 简述
这是一个典型的浮点数失精问题，无论语言，只要采用了 [IEEE-754][l2] 的浮点数标准，都会出现这个问题，有人还为此专门做了一个名为  [0.30000000000000004.com][l1] 的网站来罗列各种语言的的输出结果，下面将分析 `01 + 0.2` 的浮点数运算过程，并讨论浮点数失精的应对方案。

理解下文可能需要以下知识点：  
* [基础野：细说浮点数][l4]
* [How to round binary numbers][l5]

## 十进制转二进制
计算机内部进行浮点数运算时，是以二进制的形式的进行的，所以我们需要先把十进制转成二进制。

以 `4.375` 为例子，整数部分依照除二取余法，转换为二进制，例如
```
4 / 2 =  2..0
2 / 2 =  1..0
4 => 100.
```
小数部分的转换规则为，[对小数部分不停乘 `2`，顺序对结果取个位值，直到乘积为 `1.0`][l3]，例如
```
0.375 * 2 = 0.75
0.75 * 2 = 1.5
0.5 * 2 = 1.0
0.375 => 011
```
前后的计算值合并，则 `4.375` 的二进制表示为 `100.011`。

依上规则
```javascript
// `0.1` 的转换结果为
0.000110011001100110011001100110011(0011) // 接下去为 0011 的循环
// `0.2` 的转换结果为
0.001100110011001100110011001100110011(0011)
```

## 二进制浮点数 IEEE-754 表示
[IEEE-754][m1] 按如下定义表示一个浮点数

> ![浮点数表示][m1]  
> S 为标志位，0 为正数，1为负数。  
> M 代表有效数字，1 <= M < 2
> E 为指数位

[l1]: http://0.30000000000000004.com "0.30000000000000004.com"
[l2]: ../Resources/IEEE-754-2008.pdf "IEEE-754-2008.pdf"
[l3]: http://stackoverflow.com/a/3954640/1914450 "convert float number to binary"
[l4]: http://www.cnblogs.com/fsjohnhuang/p/5109766.html "基础野：细说浮点数"
[l5]: https://medium.com/@maximus.koretskyi/how-to-round-binary-fractions-625c8fa3a1af "How to round binary numbers"
[m1]: http://mathjax.plusman.cn/svg/?m=V%3D(-1)%5ES%20*%20M%20*%202%5EE "V=(-1)^S * M * 2^E"
